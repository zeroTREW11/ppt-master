{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { StorageVectorsApiError, StorageVectorsUnknownError } from './errors';\nimport { isPlainObject } from './helpers';\n/**\n * Extracts error message from various error response formats\n * @param err - Error object from API\n * @returns Human-readable error message\n */\nconst _getErrorMessage = err => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\n/**\n * Handles fetch errors and converts them to StorageVectors error types\n * @param error - The error caught from fetch\n * @param reject - Promise rejection function\n * @param options - Fetch options that may affect error handling\n */\nconst handleError = (error, reject, options) => __awaiter(void 0, void 0, void 0, function* () {\n  // Check if error is a Response-like object (has status and ok properties)\n  // This is more reliable than instanceof which can fail across realms\n  const isResponseLike = error && typeof error === 'object' && 'status' in error && 'ok' in error && typeof error.status === 'number';\n  if (isResponseLike && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {\n    const status = error.status || 500;\n    const responseError = error;\n    // Try to parse JSON body if available\n    if (typeof responseError.json === 'function') {\n      responseError.json().then(err => {\n        const statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || (err === null || err === void 0 ? void 0 : err.code) || status + '';\n        reject(new StorageVectorsApiError(_getErrorMessage(err), status, statusCode));\n      }).catch(() => {\n        // If JSON parsing fails, create an ApiError with the HTTP status code\n        const statusCode = status + '';\n        const message = responseError.statusText || \"HTTP \".concat(status, \" error\");\n        reject(new StorageVectorsApiError(message, status, statusCode));\n      });\n    } else {\n      // No json() method available, create error from status\n      const statusCode = status + '';\n      const message = responseError.statusText || \"HTTP \".concat(status, \" error\");\n      reject(new StorageVectorsApiError(message, status, statusCode));\n    }\n  } else {\n    reject(new StorageVectorsUnknownError(_getErrorMessage(error), error));\n  }\n});\n/**\n * Builds request parameters for fetch calls\n * @param method - HTTP method\n * @param options - Custom fetch options\n * @param parameters - Additional fetch parameters like AbortSignal\n * @param body - Request body (will be JSON stringified if plain object)\n * @returns Complete fetch request parameters\n */\nconst _getRequestParams = (method, options, parameters, body) => {\n  const params = {\n    method,\n    headers: (options === null || options === void 0 ? void 0 : options.headers) || {}\n  };\n  if (method === 'GET' || !body) {\n    return params;\n  }\n  if (isPlainObject(body)) {\n    params.headers = Object.assign({\n      'Content-Type': 'application/json'\n    }, options === null || options === void 0 ? void 0 : options.headers);\n    params.body = JSON.stringify(body);\n  } else {\n    params.body = body;\n  }\n  return Object.assign(Object.assign({}, params), parameters);\n};\n/**\n * Internal request handler that wraps fetch with error handling\n * @param fetcher - Fetch function to use\n * @param method - HTTP method\n * @param url - Request URL\n * @param options - Custom fetch options\n * @param parameters - Additional fetch parameters\n * @param body - Request body\n * @returns Promise with parsed response or error\n */\nfunction _handleRequest(fetcher, method, url, options, parameters, body) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return new Promise((resolve, reject) => {\n      fetcher(url, _getRequestParams(method, options, parameters, body)).then(result => {\n        if (!result.ok) throw result;\n        if (options === null || options === void 0 ? void 0 : options.noResolveJson) return result;\n        // Handle empty responses (204, empty body)\n        const contentType = result.headers.get('content-type');\n        if (!contentType || !contentType.includes('application/json')) {\n          return {};\n        }\n        return result.json();\n      }).then(data => resolve(data)).catch(error => handleError(error, reject, options));\n    });\n  });\n}\n/**\n * Performs a GET request\n * @param fetcher - Fetch function to use\n * @param url - Request URL\n * @param options - Custom fetch options\n * @param parameters - Additional fetch parameters\n * @returns Promise with parsed response\n */\nexport function get(fetcher, url, options, parameters) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return _handleRequest(fetcher, 'GET', url, options, parameters);\n  });\n}\n/**\n * Performs a POST request\n * @param fetcher - Fetch function to use\n * @param url - Request URL\n * @param body - Request body to be JSON stringified\n * @param options - Custom fetch options\n * @param parameters - Additional fetch parameters\n * @returns Promise with parsed response\n */\nexport function post(fetcher, url, body, options, parameters) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return _handleRequest(fetcher, 'POST', url, options, parameters, body);\n  });\n}\n/**\n * Performs a PUT request\n * @param fetcher - Fetch function to use\n * @param url - Request URL\n * @param body - Request body to be JSON stringified\n * @param options - Custom fetch options\n * @param parameters - Additional fetch parameters\n * @returns Promise with parsed response\n */\nexport function put(fetcher, url, body, options, parameters) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return _handleRequest(fetcher, 'PUT', url, options, parameters, body);\n  });\n}\n/**\n * Performs a DELETE request\n * @param fetcher - Fetch function to use\n * @param url - Request URL\n * @param body - Request body to be JSON stringified\n * @param options - Custom fetch options\n * @param parameters - Additional fetch parameters\n * @returns Promise with parsed response\n */\nexport function remove(fetcher, url, body, options, parameters) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return _handleRequest(fetcher, 'DELETE', url, options, parameters, body);\n  });\n}","map":{"version":3,"names":["StorageVectorsApiError","StorageVectorsUnknownError","isPlainObject","_getErrorMessage","err","msg","message","error_description","error","JSON","stringify","handleError","reject","options","__awaiter","isResponseLike","status","noResolveJson","responseError","json","then","statusCode","code","catch","statusText","concat","_getRequestParams","method","parameters","body","params","headers","Object","assign","_handleRequest","fetcher","url","Promise","resolve","result","ok","contentType","get","includes","data","post","put","remove"],"sources":["C:\\TUGAS\\node_modules\\@supabase\\storage-js\\src\\lib\\vectors\\fetch.ts"],"sourcesContent":["import { StorageVectorsApiError, StorageVectorsUnknownError } from './errors'\nimport { isPlainObject, resolveResponse } from './helpers'\nimport { VectorFetchParameters } from './types'\n\nexport type Fetch = typeof fetch\n\n/**\n * Options for fetch requests\n * @property headers - Custom HTTP headers\n * @property noResolveJson - If true, return raw Response instead of parsing JSON\n */\nexport interface FetchOptions {\n  headers?: {\n    [key: string]: string\n  }\n  noResolveJson?: boolean\n}\n\n/**\n * HTTP methods supported by the API\n */\nexport type RequestMethodType = 'GET' | 'POST' | 'PUT' | 'DELETE'\n\n/**\n * Extracts error message from various error response formats\n * @param err - Error object from API\n * @returns Human-readable error message\n */\nconst _getErrorMessage = (err: any): string =>\n  err.msg || err.message || err.error_description || err.error || JSON.stringify(err)\n\n/**\n * Handles fetch errors and converts them to StorageVectors error types\n * @param error - The error caught from fetch\n * @param reject - Promise rejection function\n * @param options - Fetch options that may affect error handling\n */\nconst handleError = async (\n  error: unknown,\n  reject: (reason?: any) => void,\n  options?: FetchOptions\n) => {\n  // Check if error is a Response-like object (has status and ok properties)\n  // This is more reliable than instanceof which can fail across realms\n  const isResponseLike =\n    error &&\n    typeof error === 'object' &&\n    'status' in error &&\n    'ok' in error &&\n    typeof (error as any).status === 'number'\n\n  if (isResponseLike && !options?.noResolveJson) {\n    const status = (error as any).status || 500\n    const responseError = error as any\n\n    // Try to parse JSON body if available\n    if (typeof responseError.json === 'function') {\n      responseError\n        .json()\n        .then((err: any) => {\n          const statusCode = err?.statusCode || err?.code || status + ''\n          reject(new StorageVectorsApiError(_getErrorMessage(err), status, statusCode))\n        })\n        .catch(() => {\n          // If JSON parsing fails, create an ApiError with the HTTP status code\n          const statusCode = status + ''\n          const message = responseError.statusText || `HTTP ${status} error`\n          reject(new StorageVectorsApiError(message, status, statusCode))\n        })\n    } else {\n      // No json() method available, create error from status\n      const statusCode = status + ''\n      const message = responseError.statusText || `HTTP ${status} error`\n      reject(new StorageVectorsApiError(message, status, statusCode))\n    }\n  } else {\n    reject(new StorageVectorsUnknownError(_getErrorMessage(error), error))\n  }\n}\n\n/**\n * Builds request parameters for fetch calls\n * @param method - HTTP method\n * @param options - Custom fetch options\n * @param parameters - Additional fetch parameters like AbortSignal\n * @param body - Request body (will be JSON stringified if plain object)\n * @returns Complete fetch request parameters\n */\nconst _getRequestParams = (\n  method: RequestMethodType,\n  options?: FetchOptions,\n  parameters?: VectorFetchParameters,\n  body?: object\n) => {\n  const params: { [k: string]: any } = { method, headers: options?.headers || {} }\n\n  if (method === 'GET' || !body) {\n    return params\n  }\n\n  if (isPlainObject(body)) {\n    params.headers = { 'Content-Type': 'application/json', ...options?.headers }\n    params.body = JSON.stringify(body)\n  } else {\n    params.body = body\n  }\n\n  return { ...params, ...parameters }\n}\n\n/**\n * Internal request handler that wraps fetch with error handling\n * @param fetcher - Fetch function to use\n * @param method - HTTP method\n * @param url - Request URL\n * @param options - Custom fetch options\n * @param parameters - Additional fetch parameters\n * @param body - Request body\n * @returns Promise with parsed response or error\n */\nasync function _handleRequest(\n  fetcher: Fetch,\n  method: RequestMethodType,\n  url: string,\n  options?: FetchOptions,\n  parameters?: VectorFetchParameters,\n  body?: object\n): Promise<any> {\n  return new Promise((resolve, reject) => {\n    fetcher(url, _getRequestParams(method, options, parameters, body))\n      .then((result) => {\n        if (!result.ok) throw result\n        if (options?.noResolveJson) return result\n        // Handle empty responses (204, empty body)\n        const contentType = result.headers.get('content-type')\n        if (!contentType || !contentType.includes('application/json')) {\n          return {}\n        }\n        return result.json()\n      })\n      .then((data) => resolve(data))\n      .catch((error) => handleError(error, reject, options))\n  })\n}\n\n/**\n * Performs a GET request\n * @param fetcher - Fetch function to use\n * @param url - Request URL\n * @param options - Custom fetch options\n * @param parameters - Additional fetch parameters\n * @returns Promise with parsed response\n */\nexport async function get(\n  fetcher: Fetch,\n  url: string,\n  options?: FetchOptions,\n  parameters?: VectorFetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'GET', url, options, parameters)\n}\n\n/**\n * Performs a POST request\n * @param fetcher - Fetch function to use\n * @param url - Request URL\n * @param body - Request body to be JSON stringified\n * @param options - Custom fetch options\n * @param parameters - Additional fetch parameters\n * @returns Promise with parsed response\n */\nexport async function post(\n  fetcher: Fetch,\n  url: string,\n  body: object,\n  options?: FetchOptions,\n  parameters?: VectorFetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'POST', url, options, parameters, body)\n}\n\n/**\n * Performs a PUT request\n * @param fetcher - Fetch function to use\n * @param url - Request URL\n * @param body - Request body to be JSON stringified\n * @param options - Custom fetch options\n * @param parameters - Additional fetch parameters\n * @returns Promise with parsed response\n */\nexport async function put(\n  fetcher: Fetch,\n  url: string,\n  body: object,\n  options?: FetchOptions,\n  parameters?: VectorFetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'PUT', url, options, parameters, body)\n}\n\n/**\n * Performs a DELETE request\n * @param fetcher - Fetch function to use\n * @param url - Request URL\n * @param body - Request body to be JSON stringified\n * @param options - Custom fetch options\n * @param parameters - Additional fetch parameters\n * @returns Promise with parsed response\n */\nexport async function remove(\n  fetcher: Fetch,\n  url: string,\n  body: object,\n  options?: FetchOptions,\n  parameters?: VectorFetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'DELETE', url, options, parameters, body)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}