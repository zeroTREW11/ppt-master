{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst tslib_1 = require(\"tslib\");\nconst PostgrestFilterBuilder_1 = tslib_1.__importDefault(require(\"./PostgrestFilterBuilder\"));\nclass PostgrestQueryBuilder {\n  constructor(url, _ref) {\n    let {\n      headers = {},\n      schema,\n      fetch\n    } = _ref;\n    this.url = url;\n    this.headers = new Headers(headers);\n    this.schema = schema;\n    this.fetch = fetch;\n  }\n  /**\n   * Perform a SELECT query on the table or view.\n   *\n   * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\n   *\n   * @param options - Named parameters\n   *\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   *\n   * @param options.count - Count algorithm to use to count rows in the table or view.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  select(columns, options) {\n    const {\n      head = false,\n      count\n    } = options !== null && options !== void 0 ? options : {};\n    const method = head ? 'HEAD' : 'GET';\n    // Remove whitespaces except when quoted\n    let quoted = false;\n    const cleanedColumns = (columns !== null && columns !== void 0 ? columns : '*').split('').map(c => {\n      if (/\\s/.test(c) && !quoted) {\n        return '';\n      }\n      if (c === '\"') {\n        quoted = !quoted;\n      }\n      return c;\n    }).join('');\n    this.url.searchParams.set('select', cleanedColumns);\n    if (count) {\n      this.headers.append('Prefer', \"count=\".concat(count));\n    }\n    return new PostgrestFilterBuilder_1.default({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch\n    });\n  }\n  /**\n   * Perform an INSERT into the table or view.\n   *\n   * By default, inserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to insert. Pass an object to insert a single row\n   * or an array to insert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count inserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   *\n   * @param options.defaultToNull - Make missing fields default to `null`.\n   * Otherwise, use the default value for the column. Only applies for bulk\n   * inserts.\n   */\n  insert(values) {\n    let {\n      count,\n      defaultToNull = true\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _a;\n    const method = 'POST';\n    if (count) {\n      this.headers.append('Prefer', \"count=\".concat(count));\n    }\n    if (!defaultToNull) {\n      this.headers.append('Prefer', \"missing=default\");\n    }\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map(column => \"\\\"\".concat(column, \"\\\"\"));\n        this.url.searchParams.set('columns', uniqueColumns.join(','));\n      }\n    }\n    return new PostgrestFilterBuilder_1.default({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: (_a = this.fetch) !== null && _a !== void 0 ? _a : fetch\n    });\n  }\n  /**\n   * Perform an UPSERT on the table or view. Depending on the column(s) passed\n   * to `onConflict`, `.upsert()` allows you to perform the equivalent of\n   * `.insert()` if a row with the corresponding `onConflict` columns doesn't\n   * exist, or if it does exist, perform an alternative action depending on\n   * `ignoreDuplicates`.\n   *\n   * By default, upserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to upsert with. Pass an object to upsert a\n   * single row or an array to upsert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n   * duplicate rows are determined. Two rows are duplicates if all the\n   * `onConflict` columns are equal.\n   *\n   * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n   * `false`, duplicate rows are merged with existing rows.\n   *\n   * @param options.count - Count algorithm to use to count upserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   *\n   * @param options.defaultToNull - Make missing fields default to `null`.\n   * Otherwise, use the default value for the column. This only applies when\n   * inserting new rows, not when merging with existing rows under\n   * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\n   */\n  upsert(values) {\n    let {\n      onConflict,\n      ignoreDuplicates = false,\n      count,\n      defaultToNull = true\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _a;\n    const method = 'POST';\n    this.headers.append('Prefer', \"resolution=\".concat(ignoreDuplicates ? 'ignore' : 'merge', \"-duplicates\"));\n    if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict);\n    if (count) {\n      this.headers.append('Prefer', \"count=\".concat(count));\n    }\n    if (!defaultToNull) {\n      this.headers.append('Prefer', 'missing=default');\n    }\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map(column => \"\\\"\".concat(column, \"\\\"\"));\n        this.url.searchParams.set('columns', uniqueColumns.join(','));\n      }\n    }\n    return new PostgrestFilterBuilder_1.default({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: (_a = this.fetch) !== null && _a !== void 0 ? _a : fetch\n    });\n  }\n  /**\n   * Perform an UPDATE on the table or view.\n   *\n   * By default, updated rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param values - The values to update with\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count updated rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  update(values) {\n    let {\n      count\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _a;\n    const method = 'PATCH';\n    if (count) {\n      this.headers.append('Prefer', \"count=\".concat(count));\n    }\n    return new PostgrestFilterBuilder_1.default({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: (_a = this.fetch) !== null && _a !== void 0 ? _a : fetch\n    });\n  }\n  /**\n   * Perform a DELETE on the table or view.\n   *\n   * By default, deleted rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count deleted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  delete() {\n    let {\n      count\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _a;\n    const method = 'DELETE';\n    if (count) {\n      this.headers.append('Prefer', \"count=\".concat(count));\n    }\n    return new PostgrestFilterBuilder_1.default({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: (_a = this.fetch) !== null && _a !== void 0 ? _a : fetch\n    });\n  }\n}\nexports.default = PostgrestQueryBuilder;","map":{"version":3,"names":["PostgrestFilterBuilder_1","tslib_1","__importDefault","require","PostgrestQueryBuilder","constructor","url","_ref","headers","schema","fetch","Headers","select","columns","options","head","count","method","quoted","cleanedColumns","split","map","c","test","join","searchParams","set","append","concat","default","insert","values","defaultToNull","arguments","length","undefined","Array","isArray","reduce","acc","x","Object","keys","uniqueColumns","Set","column","body","_a","upsert","onConflict","ignoreDuplicates","update","delete","exports"],"sources":["C:\\TUGAS\\node_modules\\@supabase\\postgrest-js\\src\\PostgrestQueryBuilder.ts"],"sourcesContent":["import PostgrestFilterBuilder from './PostgrestFilterBuilder'\nimport { GetResult } from './select-query-parser/result'\nimport {\n  ClientServerOptions,\n  Fetch,\n  GenericSchema,\n  GenericTable,\n  GenericView,\n} from './types/common/common'\n\nexport default class PostgrestQueryBuilder<\n  ClientOptions extends ClientServerOptions,\n  Schema extends GenericSchema,\n  Relation extends GenericTable | GenericView,\n  RelationName = unknown,\n  Relationships = Relation extends { Relationships: infer R } ? R : unknown,\n> {\n  url: URL\n  headers: Headers\n  schema?: string\n  signal?: AbortSignal\n  fetch?: Fetch\n\n  constructor(\n    url: URL,\n    {\n      headers = {},\n      schema,\n      fetch,\n    }: {\n      headers?: HeadersInit\n      schema?: string\n      fetch?: Fetch\n    }\n  ) {\n    this.url = url\n    this.headers = new Headers(headers)\n    this.schema = schema\n    this.fetch = fetch\n  }\n\n  /**\n   * Perform a SELECT query on the table or view.\n   *\n   * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\n   *\n   * @param options - Named parameters\n   *\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   *\n   * @param options.count - Count algorithm to use to count rows in the table or view.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  select<\n    Query extends string = '*',\n    ResultOne = GetResult<\n      Schema,\n      Relation['Row'],\n      RelationName,\n      Relationships,\n      Query,\n      ClientOptions\n    >,\n  >(\n    columns?: Query,\n    options?: {\n      head?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    }\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    ResultOne[],\n    RelationName,\n    Relationships,\n    'GET'\n  > {\n    const { head = false, count } = options ?? {}\n\n    const method = head ? 'HEAD' : 'GET'\n    // Remove whitespaces except when quoted\n    let quoted = false\n    const cleanedColumns = (columns ?? '*')\n      .split('')\n      .map((c) => {\n        if (/\\s/.test(c) && !quoted) {\n          return ''\n        }\n        if (c === '\"') {\n          quoted = !quoted\n        }\n        return c\n      })\n      .join('')\n    this.url.searchParams.set('select', cleanedColumns)\n\n    if (count) {\n      this.headers.append('Prefer', `count=${count}`)\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch,\n    })\n  }\n\n  // TODO(v3): Make `defaultToNull` consistent for both single & bulk inserts.\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row,\n    options?: {\n      count?: 'exact' | 'planned' | 'estimated'\n    }\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  >\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row[],\n    options?: {\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    }\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  >\n  /**\n   * Perform an INSERT into the table or view.\n   *\n   * By default, inserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to insert. Pass an object to insert a single row\n   * or an array to insert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count inserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   *\n   * @param options.defaultToNull - Make missing fields default to `null`.\n   * Otherwise, use the default value for the column. Only applies for bulk\n   * inserts.\n   */\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row | Row[],\n    {\n      count,\n      defaultToNull = true,\n    }: {\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    } = {}\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  > {\n    const method = 'POST'\n\n    if (count) {\n      this.headers.append('Prefer', `count=${count}`)\n    }\n    if (!defaultToNull) {\n      this.headers.append('Prefer', `missing=default`)\n    }\n\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\n        this.url.searchParams.set('columns', uniqueColumns.join(','))\n      }\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch ?? fetch,\n    })\n  }\n\n  // TODO(v3): Make `defaultToNull` consistent for both single & bulk upserts.\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row,\n    options?: {\n      onConflict?: string\n      ignoreDuplicates?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    }\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  >\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row[],\n    options?: {\n      onConflict?: string\n      ignoreDuplicates?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    }\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  >\n  /**\n   * Perform an UPSERT on the table or view. Depending on the column(s) passed\n   * to `onConflict`, `.upsert()` allows you to perform the equivalent of\n   * `.insert()` if a row with the corresponding `onConflict` columns doesn't\n   * exist, or if it does exist, perform an alternative action depending on\n   * `ignoreDuplicates`.\n   *\n   * By default, upserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to upsert with. Pass an object to upsert a\n   * single row or an array to upsert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n   * duplicate rows are determined. Two rows are duplicates if all the\n   * `onConflict` columns are equal.\n   *\n   * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n   * `false`, duplicate rows are merged with existing rows.\n   *\n   * @param options.count - Count algorithm to use to count upserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   *\n   * @param options.defaultToNull - Make missing fields default to `null`.\n   * Otherwise, use the default value for the column. This only applies when\n   * inserting new rows, not when merging with existing rows under\n   * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\n   */\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row | Row[],\n    {\n      onConflict,\n      ignoreDuplicates = false,\n      count,\n      defaultToNull = true,\n    }: {\n      onConflict?: string\n      ignoreDuplicates?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    } = {}\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  > {\n    const method = 'POST'\n\n    this.headers.append('Prefer', `resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`)\n\n    if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict)\n    if (count) {\n      this.headers.append('Prefer', `count=${count}`)\n    }\n    if (!defaultToNull) {\n      this.headers.append('Prefer', 'missing=default')\n    }\n\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\n        this.url.searchParams.set('columns', uniqueColumns.join(','))\n      }\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch ?? fetch,\n    })\n  }\n\n  /**\n   * Perform an UPDATE on the table or view.\n   *\n   * By default, updated rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param values - The values to update with\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count updated rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  update<Row extends Relation extends { Update: unknown } ? Relation['Update'] : never>(\n    values: Row,\n    {\n      count,\n    }: {\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'PATCH'\n  > {\n    const method = 'PATCH'\n    if (count) {\n      this.headers.append('Prefer', `count=${count}`)\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch ?? fetch,\n    })\n  }\n\n  /**\n   * Perform a DELETE on the table or view.\n   *\n   * By default, deleted rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count deleted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  delete({\n    count,\n  }: {\n    count?: 'exact' | 'planned' | 'estimated'\n  } = {}): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'DELETE'\n  > {\n    const method = 'DELETE'\n    if (count) {\n      this.headers.append('Prefer', `count=${count}`)\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch ?? fetch,\n    })\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}