{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { DEFAULT_HEADERS } from './constants';\nimport { isStorageVectorsError } from './errors';\nimport { post } from './fetch';\nimport { resolveFetch } from './helpers';\n/**\n * API class for managing Vector Buckets\n * Provides methods for creating, reading, listing, and deleting vector buckets\n */\nexport default class VectorBucketApi {\n  /**\n   * Creates a new VectorBucketApi instance\n   * @param url - The base URL for the storage vectors API\n   * @param headers - HTTP headers to include in requests\n   * @param fetch - Optional custom fetch implementation\n   */\n  constructor(url, headers = {}, fetch) {\n    this.shouldThrowOnError = false;\n    this.url = url.replace(/\\/$/, '');\n    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS), headers);\n    this.fetch = resolveFetch(fetch);\n  }\n  /**\n   * Enable throwing errors instead of returning them in the response\n   * When enabled, failed operations will throw instead of returning { data: null, error }\n   *\n   * @returns This instance for method chaining\n   * @example\n   * ```typescript\n   * const client = new VectorBucketApi(url, headers)\n   * client.throwOnError()\n   * const { data } = await client.createBucket('my-bucket') // throws on error\n   * ```\n   */\n  throwOnError() {\n    this.shouldThrowOnError = true;\n    return this;\n  }\n  /**\n   * Creates a new vector bucket\n   * Vector buckets are containers for vector indexes and their data\n   *\n   * @param vectorBucketName - Unique name for the vector bucket\n   * @returns Promise with empty response on success or error\n   *\n   * @throws {StorageVectorsApiError} With code:\n   * - `S3VectorConflictException` if bucket already exists (HTTP 409)\n   * - `S3VectorMaxBucketsExceeded` if quota exceeded (HTTP 400)\n   * - `InternalError` for server errors (HTTP 500)\n   *\n   * @example\n   * ```typescript\n   * const { data, error } = await client.createBucket('embeddings-prod')\n   * if (error) {\n   *   console.error('Failed to create bucket:', error.message)\n   * }\n   * ```\n   */\n  createBucket(vectorBucketName) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/CreateVectorBucket`, {\n          vectorBucketName\n        }, {\n          headers: this.headers\n        });\n        return {\n          data: data || {},\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageVectorsError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Retrieves metadata for a specific vector bucket\n   * Returns bucket configuration including encryption settings and creation time\n   *\n   * @param vectorBucketName - Name of the vector bucket to retrieve\n   * @returns Promise with bucket metadata or error\n   *\n   * @throws {StorageVectorsApiError} With code:\n   * - `S3VectorNotFoundException` if bucket doesn't exist (HTTP 404)\n   * - `InternalError` for server errors (HTTP 500)\n   *\n   * @example\n   * ```typescript\n   * const { data, error } = await client.getBucket('embeddings-prod')\n   * if (data) {\n   *   console.log('Bucket created at:', new Date(data.vectorBucket.creationTime! * 1000))\n   * }\n   * ```\n   */\n  getBucket(vectorBucketName) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/GetVectorBucket`, {\n          vectorBucketName\n        }, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageVectorsError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Lists vector buckets with optional filtering and pagination\n   * Supports prefix-based filtering and paginated results\n   *\n   * @param options - Listing options\n   * @param options.prefix - Filter buckets by name prefix\n   * @param options.maxResults - Maximum results per page (default: 100)\n   * @param options.nextToken - Pagination token from previous response\n   * @returns Promise with list of buckets and pagination token\n   *\n   * @throws {StorageVectorsApiError} With code:\n   * - `InternalError` for server errors (HTTP 500)\n   *\n   * @example\n   * ```typescript\n   * // List all buckets with prefix 'prod-'\n   * const { data, error } = await client.listBuckets({ prefix: 'prod-' })\n   * if (data) {\n   *   console.log('Found buckets:', data.buckets.length)\n   *   // Fetch next page if available\n   *   if (data.nextToken) {\n   *     const next = await client.listBuckets({ nextToken: data.nextToken })\n   *   }\n   * }\n   * ```\n   */\n  listBuckets() {\n    return __awaiter(this, arguments, void 0, function* (options = {}) {\n      try {\n        const data = yield post(this.fetch, `${this.url}/ListVectorBuckets`, options, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageVectorsError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Deletes a vector bucket\n   * Bucket must be empty before deletion (all indexes must be removed first)\n   *\n   * @param vectorBucketName - Name of the vector bucket to delete\n   * @returns Promise with empty response on success or error\n   *\n   * @throws {StorageVectorsApiError} With code:\n   * - `S3VectorBucketNotEmpty` if bucket contains indexes (HTTP 400)\n   * - `S3VectorNotFoundException` if bucket doesn't exist (HTTP 404)\n   * - `InternalError` for server errors (HTTP 500)\n   *\n   * @example\n   * ```typescript\n   * // Delete all indexes first, then delete bucket\n   * const { error } = await client.deleteBucket('old-bucket')\n   * if (error?.statusCode === 'S3VectorBucketNotEmpty') {\n   *   console.error('Must delete all indexes first')\n   * }\n   * ```\n   */\n  deleteBucket(vectorBucketName) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/DeleteVectorBucket`, {\n          vectorBucketName\n        }, {\n          headers: this.headers\n        });\n        return {\n          data: data || {},\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageVectorsError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n}","map":{"version":3,"names":["DEFAULT_HEADERS","isStorageVectorsError","post","resolveFetch","VectorBucketApi","constructor","url","headers","fetch","shouldThrowOnError","replace","Object","assign","throwOnError","createBucket","vectorBucketName","data","error","getBucket","listBuckets","options","deleteBucket"],"sources":["C:\\TUGAS\\node_modules\\@supabase\\storage-js\\src\\lib\\vectors\\VectorBucketApi.ts"],"sourcesContent":["import { DEFAULT_HEADERS } from './constants'\nimport { isStorageVectorsError } from './errors'\nimport { Fetch, post } from './fetch'\nimport { resolveFetch } from './helpers'\nimport {\n  ApiResponse,\n  VectorBucket,\n  ListVectorBucketsOptions,\n  ListVectorBucketsResponse,\n} from './types'\n\n/**\n * API class for managing Vector Buckets\n * Provides methods for creating, reading, listing, and deleting vector buckets\n */\nexport default class VectorBucketApi {\n  protected url: string\n  protected headers: { [key: string]: string }\n  protected fetch: Fetch\n  protected shouldThrowOnError = false\n\n  /**\n   * Creates a new VectorBucketApi instance\n   * @param url - The base URL for the storage vectors API\n   * @param headers - HTTP headers to include in requests\n   * @param fetch - Optional custom fetch implementation\n   */\n  constructor(url: string, headers: { [key: string]: string } = {}, fetch?: Fetch) {\n    this.url = url.replace(/\\/$/, '')\n    this.headers = { ...DEFAULT_HEADERS, ...headers }\n    this.fetch = resolveFetch(fetch)\n  }\n\n  /**\n   * Enable throwing errors instead of returning them in the response\n   * When enabled, failed operations will throw instead of returning { data: null, error }\n   *\n   * @returns This instance for method chaining\n   * @example\n   * ```typescript\n   * const client = new VectorBucketApi(url, headers)\n   * client.throwOnError()\n   * const { data } = await client.createBucket('my-bucket') // throws on error\n   * ```\n   */\n  public throwOnError(): this {\n    this.shouldThrowOnError = true\n    return this\n  }\n\n  /**\n   * Creates a new vector bucket\n   * Vector buckets are containers for vector indexes and their data\n   *\n   * @param vectorBucketName - Unique name for the vector bucket\n   * @returns Promise with empty response on success or error\n   *\n   * @throws {StorageVectorsApiError} With code:\n   * - `S3VectorConflictException` if bucket already exists (HTTP 409)\n   * - `S3VectorMaxBucketsExceeded` if quota exceeded (HTTP 400)\n   * - `InternalError` for server errors (HTTP 500)\n   *\n   * @example\n   * ```typescript\n   * const { data, error } = await client.createBucket('embeddings-prod')\n   * if (error) {\n   *   console.error('Failed to create bucket:', error.message)\n   * }\n   * ```\n   */\n  async createBucket(vectorBucketName: string): Promise<ApiResponse<undefined>> {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/CreateVectorBucket`,\n        { vectorBucketName },\n        { headers: this.headers }\n      )\n      return { data: data || {}, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageVectorsError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Retrieves metadata for a specific vector bucket\n   * Returns bucket configuration including encryption settings and creation time\n   *\n   * @param vectorBucketName - Name of the vector bucket to retrieve\n   * @returns Promise with bucket metadata or error\n   *\n   * @throws {StorageVectorsApiError} With code:\n   * - `S3VectorNotFoundException` if bucket doesn't exist (HTTP 404)\n   * - `InternalError` for server errors (HTTP 500)\n   *\n   * @example\n   * ```typescript\n   * const { data, error } = await client.getBucket('embeddings-prod')\n   * if (data) {\n   *   console.log('Bucket created at:', new Date(data.vectorBucket.creationTime! * 1000))\n   * }\n   * ```\n   */\n  async getBucket(\n    vectorBucketName: string\n  ): Promise<ApiResponse<{ vectorBucket: VectorBucket }>> {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/GetVectorBucket`,\n        { vectorBucketName },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageVectorsError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Lists vector buckets with optional filtering and pagination\n   * Supports prefix-based filtering and paginated results\n   *\n   * @param options - Listing options\n   * @param options.prefix - Filter buckets by name prefix\n   * @param options.maxResults - Maximum results per page (default: 100)\n   * @param options.nextToken - Pagination token from previous response\n   * @returns Promise with list of buckets and pagination token\n   *\n   * @throws {StorageVectorsApiError} With code:\n   * - `InternalError` for server errors (HTTP 500)\n   *\n   * @example\n   * ```typescript\n   * // List all buckets with prefix 'prod-'\n   * const { data, error } = await client.listBuckets({ prefix: 'prod-' })\n   * if (data) {\n   *   console.log('Found buckets:', data.buckets.length)\n   *   // Fetch next page if available\n   *   if (data.nextToken) {\n   *     const next = await client.listBuckets({ nextToken: data.nextToken })\n   *   }\n   * }\n   * ```\n   */\n  async listBuckets(\n    options: ListVectorBucketsOptions = {}\n  ): Promise<ApiResponse<ListVectorBucketsResponse>> {\n    try {\n      const data = await post(this.fetch, `${this.url}/ListVectorBuckets`, options, {\n        headers: this.headers,\n      })\n      return { data, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageVectorsError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Deletes a vector bucket\n   * Bucket must be empty before deletion (all indexes must be removed first)\n   *\n   * @param vectorBucketName - Name of the vector bucket to delete\n   * @returns Promise with empty response on success or error\n   *\n   * @throws {StorageVectorsApiError} With code:\n   * - `S3VectorBucketNotEmpty` if bucket contains indexes (HTTP 400)\n   * - `S3VectorNotFoundException` if bucket doesn't exist (HTTP 404)\n   * - `InternalError` for server errors (HTTP 500)\n   *\n   * @example\n   * ```typescript\n   * // Delete all indexes first, then delete bucket\n   * const { error } = await client.deleteBucket('old-bucket')\n   * if (error?.statusCode === 'S3VectorBucketNotEmpty') {\n   *   console.error('Must delete all indexes first')\n   * }\n   * ```\n   */\n  async deleteBucket(vectorBucketName: string): Promise<ApiResponse<undefined>> {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/DeleteVectorBucket`,\n        { vectorBucketName },\n        { headers: this.headers }\n      )\n      return { data: data || {}, error: null }\n    } catch (error) {\n      if (this.shouldThrowOnError) {\n        throw error\n      }\n      if (isStorageVectorsError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}