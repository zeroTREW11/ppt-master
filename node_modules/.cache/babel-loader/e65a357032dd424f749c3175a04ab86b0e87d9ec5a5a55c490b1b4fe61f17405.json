{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { base64UrlToUint8Array, bytesToBase64URL } from './base64url';\nimport { AuthError, AuthUnknownError, isAuthError } from './errors';\nimport { isBrowser } from './helpers';\nimport { identifyAuthenticationError, identifyRegistrationError, isWebAuthnError, WebAuthnError, WebAuthnUnknownError } from './webauthn.errors';\nexport { WebAuthnError, isWebAuthnError, identifyRegistrationError, identifyAuthenticationError };\n/**\n * WebAuthn abort service to manage ceremony cancellation.\n * Ensures only one WebAuthn ceremony is active at a time to prevent \"operation already in progress\" errors.\n *\n * @experimental This class is experimental and may change in future releases\n * @see {@link https://w3c.github.io/webauthn/#sctn-automation-webdriver-capability W3C WebAuthn Spec - Aborting Ceremonies}\n */\nexport class WebAuthnAbortService {\n  /**\n   * Create an abort signal for a new WebAuthn operation.\n   * Automatically cancels any existing operation.\n   *\n   * @returns {AbortSignal} Signal to pass to navigator.credentials.create() or .get()\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal MDN - AbortSignal}\n   */\n  createNewAbortSignal() {\n    // Abort any existing calls to navigator.credentials.create() or navigator.credentials.get()\n    if (this.controller) {\n      const abortError = new Error('Cancelling existing WebAuthn API call for new one');\n      abortError.name = 'AbortError';\n      this.controller.abort(abortError);\n    }\n    const newController = new AbortController();\n    this.controller = newController;\n    return newController.signal;\n  }\n  /**\n   * Manually cancel the current WebAuthn operation.\n   * Useful for cleaning up when user cancels or navigates away.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort MDN - AbortController.abort}\n   */\n  cancelCeremony() {\n    if (this.controller) {\n      const abortError = new Error('Manually cancelling existing WebAuthn API call');\n      abortError.name = 'AbortError';\n      this.controller.abort(abortError);\n      this.controller = undefined;\n    }\n  }\n}\n/**\n * Singleton instance to ensure only one WebAuthn ceremony is active at a time.\n * This prevents \"operation already in progress\" errors when retrying WebAuthn operations.\n *\n * @experimental This instance is experimental and may change in future releases\n */\nexport const webAuthnAbortService = new WebAuthnAbortService();\n/**\n * Convert base64url encoded strings in WebAuthn credential creation options to ArrayBuffers\n * as required by the WebAuthn browser API.\n * Supports both native WebAuthn Level 3 parseCreationOptionsFromJSON and manual fallback.\n *\n * @param {ServerCredentialCreationOptions} options - JSON options from server with base64url encoded fields\n * @returns {PublicKeyCredentialCreationOptionsFuture} Options ready for navigator.credentials.create()\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseCreationOptionsFromJSON W3C WebAuthn Spec - parseCreationOptionsFromJSON}\n */\nexport function deserializeCredentialCreationOptions(options) {\n  if (!options) {\n    throw new Error('Credential creation options are required');\n  }\n  // Check if the native parseCreationOptionsFromJSON method is available\n  if (typeof PublicKeyCredential !== 'undefined' && 'parseCreationOptionsFromJSON' in PublicKeyCredential && typeof PublicKeyCredential.parseCreationOptionsFromJSON === 'function') {\n    // Use the native WebAuthn Level 3 method\n    return PublicKeyCredential.parseCreationOptionsFromJSON(/** we assert the options here as typescript still doesn't know about future webauthn types */\n    options);\n  }\n  // Fallback to manual parsing for browsers that don't support the native method\n  // Destructure to separate fields that need transformation\n  const {\n      challenge: challengeStr,\n      user: userOpts,\n      excludeCredentials\n    } = options,\n    restOptions = __rest(options\n    // Convert challenge from base64url to ArrayBuffer\n    , [\"challenge\", \"user\", \"excludeCredentials\"]);\n  // Convert challenge from base64url to ArrayBuffer\n  const challenge = base64UrlToUint8Array(challengeStr).buffer;\n  // Convert user.id from base64url to ArrayBuffer\n  const user = Object.assign(Object.assign({}, userOpts), {\n    id: base64UrlToUint8Array(userOpts.id).buffer\n  });\n  // Build the result object\n  const result = Object.assign(Object.assign({}, restOptions), {\n    challenge,\n    user\n  });\n  // Only add excludeCredentials if it exists\n  if (excludeCredentials && excludeCredentials.length > 0) {\n    result.excludeCredentials = new Array(excludeCredentials.length);\n    for (let i = 0; i < excludeCredentials.length; i++) {\n      const cred = excludeCredentials[i];\n      result.excludeCredentials[i] = Object.assign(Object.assign({}, cred), {\n        id: base64UrlToUint8Array(cred.id).buffer,\n        type: cred.type || 'public-key',\n        // Cast transports to handle future transport types like \"cable\"\n        transports: cred.transports\n      });\n    }\n  }\n  return result;\n}\n/**\n * Convert base64url encoded strings in WebAuthn credential request options to ArrayBuffers\n * as required by the WebAuthn browser API.\n * Supports both native WebAuthn Level 3 parseRequestOptionsFromJSON and manual fallback.\n *\n * @param {ServerCredentialRequestOptions} options - JSON options from server with base64url encoded fields\n * @returns {PublicKeyCredentialRequestOptionsFuture} Options ready for navigator.credentials.get()\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseRequestOptionsFromJSON W3C WebAuthn Spec - parseRequestOptionsFromJSON}\n */\nexport function deserializeCredentialRequestOptions(options) {\n  if (!options) {\n    throw new Error('Credential request options are required');\n  }\n  // Check if the native parseRequestOptionsFromJSON method is available\n  if (typeof PublicKeyCredential !== 'undefined' && 'parseRequestOptionsFromJSON' in PublicKeyCredential && typeof PublicKeyCredential.parseRequestOptionsFromJSON === 'function') {\n    // Use the native WebAuthn Level 3 method\n    return PublicKeyCredential.parseRequestOptionsFromJSON(options);\n  }\n  // Fallback to manual parsing for browsers that don't support the native method\n  // Destructure to separate fields that need transformation\n  const {\n      challenge: challengeStr,\n      allowCredentials\n    } = options,\n    restOptions = __rest(options\n    // Convert challenge from base64url to ArrayBuffer\n    , [\"challenge\", \"allowCredentials\"]);\n  // Convert challenge from base64url to ArrayBuffer\n  const challenge = base64UrlToUint8Array(challengeStr).buffer;\n  // Build the result object\n  const result = Object.assign(Object.assign({}, restOptions), {\n    challenge\n  });\n  // Only add allowCredentials if it exists\n  if (allowCredentials && allowCredentials.length > 0) {\n    result.allowCredentials = new Array(allowCredentials.length);\n    for (let i = 0; i < allowCredentials.length; i++) {\n      const cred = allowCredentials[i];\n      result.allowCredentials[i] = Object.assign(Object.assign({}, cred), {\n        id: base64UrlToUint8Array(cred.id).buffer,\n        type: cred.type || 'public-key',\n        // Cast transports to handle future transport types like \"cable\"\n        transports: cred.transports\n      });\n    }\n  }\n  return result;\n}\n/**\n * Convert a registration/enrollment credential response to server format.\n * Serializes binary fields to base64url for JSON transmission.\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\n *\n * @param {RegistrationCredential} credential - Credential from navigator.credentials.create()\n * @returns {RegistrationResponseJSON} JSON-serializable credential for server\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\n */\nexport function serializeCredentialCreationResponse(credential) {\n  var _a;\n  // Check if the credential instance has the toJSON method\n  if ('toJSON' in credential && typeof credential.toJSON === 'function') {\n    // Use the native WebAuthn Level 3 method\n    return credential.toJSON();\n  }\n  const credentialWithAttachment = credential;\n  return {\n    id: credential.id,\n    rawId: credential.id,\n    response: {\n      attestationObject: bytesToBase64URL(new Uint8Array(credential.response.attestationObject)),\n      clientDataJSON: bytesToBase64URL(new Uint8Array(credential.response.clientDataJSON))\n    },\n    type: 'public-key',\n    clientExtensionResults: credential.getClientExtensionResults(),\n    // Convert null to undefined and cast to AuthenticatorAttachment type\n    authenticatorAttachment: (_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined\n  };\n}\n/**\n * Convert an authentication/verification credential response to server format.\n * Serializes binary fields to base64url for JSON transmission.\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\n *\n * @param {AuthenticationCredential} credential - Credential from navigator.credentials.get()\n * @returns {AuthenticationResponseJSON} JSON-serializable credential for server\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\n */\nexport function serializeCredentialRequestResponse(credential) {\n  var _a;\n  // Check if the credential instance has the toJSON method\n  if ('toJSON' in credential && typeof credential.toJSON === 'function') {\n    // Use the native WebAuthn Level 3 method\n    return credential.toJSON();\n  }\n  // Fallback to manual conversion for browsers that don't support toJSON\n  // Access authenticatorAttachment via type assertion to handle TypeScript version differences\n  // @simplewebauthn/types includes this property but base TypeScript 4.7.4 doesn't\n  const credentialWithAttachment = credential;\n  const clientExtensionResults = credential.getClientExtensionResults();\n  const assertionResponse = credential.response;\n  return {\n    id: credential.id,\n    rawId: credential.id,\n    // W3C spec expects rawId to match id for JSON format\n    response: {\n      authenticatorData: bytesToBase64URL(new Uint8Array(assertionResponse.authenticatorData)),\n      clientDataJSON: bytesToBase64URL(new Uint8Array(assertionResponse.clientDataJSON)),\n      signature: bytesToBase64URL(new Uint8Array(assertionResponse.signature)),\n      userHandle: assertionResponse.userHandle ? bytesToBase64URL(new Uint8Array(assertionResponse.userHandle)) : undefined\n    },\n    type: 'public-key',\n    clientExtensionResults,\n    // Convert null to undefined and cast to AuthenticatorAttachment type\n    authenticatorAttachment: (_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined\n  };\n}\n/**\n * A simple test to determine if a hostname is a properly-formatted domain name.\n * Considers localhost valid for development environments.\n *\n * A \"valid domain\" is defined here: https://url.spec.whatwg.org/#valid-domain\n *\n * Regex sourced from here:\n * https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch08s15.html\n *\n * @param {string} hostname - The hostname to validate\n * @returns {boolean} True if valid domain or localhost\n * @see {@link https://url.spec.whatwg.org/#valid-domain WHATWG URL Spec - Valid Domain}\n */\nexport function isValidDomain(hostname) {\n  return (\n    // Consider localhost valid as well since it's okay wrt Secure Contexts\n    hostname === 'localhost' || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname)\n  );\n}\n/**\n * Determine if the browser is capable of WebAuthn.\n * Checks for necessary Web APIs: PublicKeyCredential and Credential Management.\n *\n * @returns {boolean} True if browser supports WebAuthn\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential#browser_compatibility MDN - PublicKeyCredential Browser Compatibility}\n */\nfunction browserSupportsWebAuthn() {\n  var _a, _b;\n  return !!(isBrowser() && 'PublicKeyCredential' in window && window.PublicKeyCredential && 'credentials' in navigator && typeof ((_a = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _a === void 0 ? void 0 : _a.create) === 'function' && typeof ((_b = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _b === void 0 ? void 0 : _b.get) === 'function');\n}\n/**\n * Create a WebAuthn credential using the browser's credentials API.\n * Wraps navigator.credentials.create() with error handling.\n *\n * @param {CredentialCreationOptions} options - Options including publicKey parameters\n * @returns {Promise<RequestResult<RegistrationCredential, WebAuthnError>>} Created credential or error\n * @see {@link https://w3c.github.io/webauthn/#sctn-createCredential W3C WebAuthn Spec - Create Credential}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/create MDN - credentials.create}\n */\nexport async function createCredential(options) {\n  try {\n    const response = await navigator.credentials.create(/** we assert the type here until typescript types are updated */\n    options);\n    if (!response) {\n      return {\n        data: null,\n        error: new WebAuthnUnknownError('Empty credential response', response)\n      };\n    }\n    if (!(response instanceof PublicKeyCredential)) {\n      return {\n        data: null,\n        error: new WebAuthnUnknownError('Browser returned unexpected credential type', response)\n      };\n    }\n    return {\n      data: response,\n      error: null\n    };\n  } catch (err) {\n    return {\n      data: null,\n      error: identifyRegistrationError({\n        error: err,\n        options\n      })\n    };\n  }\n}\n/**\n * Get a WebAuthn credential using the browser's credentials API.\n * Wraps navigator.credentials.get() with error handling.\n *\n * @param {CredentialRequestOptions} options - Options including publicKey parameters\n * @returns {Promise<RequestResult<AuthenticationCredential, WebAuthnError>>} Retrieved credential or error\n * @see {@link https://w3c.github.io/webauthn/#sctn-getAssertion W3C WebAuthn Spec - Get Assertion}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get MDN - credentials.get}\n */\nexport async function getCredential(options) {\n  try {\n    const response = await navigator.credentials.get(/** we assert the type here until typescript types are updated */\n    options);\n    if (!response) {\n      return {\n        data: null,\n        error: new WebAuthnUnknownError('Empty credential response', response)\n      };\n    }\n    if (!(response instanceof PublicKeyCredential)) {\n      return {\n        data: null,\n        error: new WebAuthnUnknownError('Browser returned unexpected credential type', response)\n      };\n    }\n    return {\n      data: response,\n      error: null\n    };\n  } catch (err) {\n    return {\n      data: null,\n      error: identifyAuthenticationError({\n        error: err,\n        options\n      })\n    };\n  }\n}\nexport const DEFAULT_CREATION_OPTIONS = {\n  hints: ['security-key'],\n  authenticatorSelection: {\n    authenticatorAttachment: 'cross-platform',\n    requireResidentKey: false,\n    /** set to preferred because older yubikeys don't have PIN/Biometric */\n    userVerification: 'preferred',\n    residentKey: 'discouraged'\n  },\n  attestation: 'none'\n};\nexport const DEFAULT_REQUEST_OPTIONS = {\n  /** set to preferred because older yubikeys don't have PIN/Biometric */\n  userVerification: 'preferred',\n  hints: ['security-key']\n};\nfunction deepMerge() {\n  const isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n  const isArrayBufferLike = val => val instanceof ArrayBuffer || ArrayBuffer.isView(val);\n  const result = {};\n  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n    sources[_key] = arguments[_key];\n  }\n  for (const source of sources) {\n    if (!source) continue;\n    for (const key in source) {\n      const value = source[key];\n      if (value === undefined) continue;\n      if (Array.isArray(value)) {\n        // preserve array reference, including unions like AuthenticatorTransport[]\n        result[key] = value;\n      } else if (isArrayBufferLike(value)) {\n        result[key] = value;\n      } else if (isObject(value)) {\n        const existing = result[key];\n        if (isObject(existing)) {\n          result[key] = deepMerge(existing, value);\n        } else {\n          result[key] = deepMerge(value);\n        }\n      } else {\n        result[key] = value;\n      }\n    }\n  }\n  return result;\n}\n/**\n * Merges WebAuthn credential creation options with overrides.\n * Sets sensible defaults for authenticator selection and extensions.\n *\n * @param {PublicKeyCredentialCreationOptionsFuture} baseOptions - The base options from the server\n * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Optional overrides to apply\n * @param {string} friendlyName - Optional friendly name for the credential\n * @returns {PublicKeyCredentialCreationOptionsFuture} Merged credential creation options\n * @see {@link https://w3c.github.io/webauthn/#dictdef-authenticatorselectioncriteria W3C WebAuthn Spec - AuthenticatorSelectionCriteria}\n */\nexport function mergeCredentialCreationOptions(baseOptions, overrides) {\n  return deepMerge(DEFAULT_CREATION_OPTIONS, baseOptions, overrides || {});\n}\n/**\n * Merges WebAuthn credential request options with overrides.\n * Sets sensible defaults for user verification and hints.\n *\n * @param {PublicKeyCredentialRequestOptionsFuture} baseOptions - The base options from the server\n * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Optional overrides to apply\n * @returns {PublicKeyCredentialRequestOptionsFuture} Merged credential request options\n * @see {@link https://w3c.github.io/webauthn/#dictdef-publickeycredentialrequestoptions W3C WebAuthn Spec - PublicKeyCredentialRequestOptions}\n */\nexport function mergeCredentialRequestOptions(baseOptions, overrides) {\n  return deepMerge(DEFAULT_REQUEST_OPTIONS, baseOptions, overrides || {});\n}\n/**\n * WebAuthn API wrapper for Supabase Auth.\n * Provides methods for enrolling, challenging, verifying, authenticating, and registering WebAuthn credentials.\n *\n * @experimental This API is experimental and may change in future releases\n * @see {@link https://w3c.github.io/webauthn/ W3C WebAuthn Specification}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API MDN - Web Authentication API}\n */\nexport class WebAuthnApi {\n  constructor(client) {\n    this.client = client;\n    // Bind all methods so they can be destructured\n    this.enroll = this._enroll.bind(this);\n    this.challenge = this._challenge.bind(this);\n    this.verify = this._verify.bind(this);\n    this.authenticate = this._authenticate.bind(this);\n    this.register = this._register.bind(this);\n  }\n  /**\n   * Enroll a new WebAuthn factor.\n   * Creates an unverified WebAuthn factor that must be verified with a credential.\n   *\n   * @experimental This method is experimental and may change in future releases\n   * @param {Omit<MFAEnrollWebauthnParams, 'factorType'>} params - Enrollment parameters (friendlyName required)\n   * @returns {Promise<AuthMFAEnrollWebauthnResponse>} Enrolled factor details or error\n   * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registering a New Credential}\n   */\n  async _enroll(params) {\n    return this.client.mfa.enroll(Object.assign(Object.assign({}, params), {\n      factorType: 'webauthn'\n    }));\n  }\n  /**\n   * Challenge for WebAuthn credential creation or authentication.\n   * Combines server challenge with browser credential operations.\n   * Handles both registration (create) and authentication (request) flows.\n   *\n   * @experimental This method is experimental and may change in future releases\n   * @param {MFAChallengeWebauthnParams & { friendlyName?: string; signal?: AbortSignal }} params - Challenge parameters including factorId\n   * @param {Object} overrides - Allows you to override the parameters passed to navigator.credentials\n   * @param {PublicKeyCredentialCreationOptionsFuture} overrides.create - Override options for credential creation\n   * @param {PublicKeyCredentialRequestOptionsFuture} overrides.request - Override options for credential request\n   * @returns {Promise<RequestResult>} Challenge response with credential or error\n   * @see {@link https://w3c.github.io/webauthn/#sctn-credential-creation W3C WebAuthn Spec - Credential Creation}\n   * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying Assertion}\n   */\n  async _challenge(_ref, overrides) {\n    let {\n      factorId,\n      webauthn,\n      friendlyName,\n      signal\n    } = _ref;\n    try {\n      // Get challenge from server using the client's MFA methods\n      const {\n        data: challengeResponse,\n        error: challengeError\n      } = await this.client.mfa.challenge({\n        factorId,\n        webauthn\n      });\n      if (!challengeResponse) {\n        return {\n          data: null,\n          error: challengeError\n        };\n      }\n      const abortSignal = signal !== null && signal !== void 0 ? signal : webAuthnAbortService.createNewAbortSignal();\n      /** webauthn will fail if either of the name/displayname are blank */\n      if (challengeResponse.webauthn.type === 'create') {\n        const {\n          user\n        } = challengeResponse.webauthn.credential_options.publicKey;\n        if (!user.name) {\n          user.name = \"\".concat(user.id, \":\").concat(friendlyName);\n        }\n        if (!user.displayName) {\n          user.displayName = user.name;\n        }\n      }\n      switch (challengeResponse.webauthn.type) {\n        case 'create':\n          {\n            const options = mergeCredentialCreationOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.create);\n            const {\n              data,\n              error\n            } = await createCredential({\n              publicKey: options,\n              signal: abortSignal\n            });\n            if (data) {\n              return {\n                data: {\n                  factorId,\n                  challengeId: challengeResponse.id,\n                  webauthn: {\n                    type: challengeResponse.webauthn.type,\n                    credential_response: data\n                  }\n                },\n                error: null\n              };\n            }\n            return {\n              data: null,\n              error\n            };\n          }\n        case 'request':\n          {\n            const options = mergeCredentialRequestOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.request);\n            const {\n              data,\n              error\n            } = await getCredential(Object.assign(Object.assign({}, challengeResponse.webauthn.credential_options), {\n              publicKey: options,\n              signal: abortSignal\n            }));\n            if (data) {\n              return {\n                data: {\n                  factorId,\n                  challengeId: challengeResponse.id,\n                  webauthn: {\n                    type: challengeResponse.webauthn.type,\n                    credential_response: data\n                  }\n                },\n                error: null\n              };\n            }\n            return {\n              data: null,\n              error\n            };\n          }\n      }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: null,\n          error\n        };\n      }\n      return {\n        data: null,\n        error: new AuthUnknownError('Unexpected error in challenge', error)\n      };\n    }\n  }\n  /**\n   * Verify a WebAuthn credential with the server.\n   * Completes the WebAuthn ceremony by sending the credential to the server for verification.\n   *\n   * @experimental This method is experimental and may change in future releases\n   * @param {Object} params - Verification parameters\n   * @param {string} params.challengeId - ID of the challenge being verified\n   * @param {string} params.factorId - ID of the WebAuthn factor\n   * @param {MFAVerifyWebauthnParams<T>['webauthn']} params.webauthn - WebAuthn credential response\n   * @returns {Promise<AuthMFAVerifyResponse>} Verification result with session or error\n   * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying an Authentication Assertion}\n   * */\n  async _verify(_ref2) {\n    let {\n      challengeId,\n      factorId,\n      webauthn\n    } = _ref2;\n    return this.client.mfa.verify({\n      factorId,\n      challengeId,\n      webauthn: webauthn\n    });\n  }\n  /**\n   * Complete WebAuthn authentication flow.\n   * Performs challenge and verification in a single operation for existing credentials.\n   *\n   * @experimental This method is experimental and may change in future releases\n   * @param {Object} params - Authentication parameters\n   * @param {string} params.factorId - ID of the WebAuthn factor to authenticate with\n   * @param {Object} params.webauthn - WebAuthn configuration\n   * @param {string} params.webauthn.rpId - Relying Party ID (defaults to current hostname)\n   * @param {string[]} params.webauthn.rpOrigins - Allowed origins (defaults to current origin)\n   * @param {AbortSignal} params.webauthn.signal - Optional abort signal\n   * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Override options for navigator.credentials.get\n   * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Authentication result\n   * @see {@link https://w3c.github.io/webauthn/#sctn-authentication W3C WebAuthn Spec - Authentication Ceremony}\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions MDN - PublicKeyCredentialRequestOptions}\n   */\n  async _authenticate(_ref3, overrides) {\n    let {\n      factorId,\n      webauthn: {\n        rpId = typeof window !== 'undefined' ? window.location.hostname : undefined,\n        rpOrigins = typeof window !== 'undefined' ? [window.location.origin] : undefined,\n        signal\n      }\n    } = _ref3;\n    if (!rpId) {\n      return {\n        data: null,\n        error: new AuthError('rpId is required for WebAuthn authentication')\n      };\n    }\n    try {\n      if (!browserSupportsWebAuthn()) {\n        return {\n          data: null,\n          error: new AuthUnknownError('Browser does not support WebAuthn', null)\n        };\n      }\n      // Get challenge and credential\n      const {\n        data: challengeResponse,\n        error: challengeError\n      } = await this.challenge({\n        factorId,\n        webauthn: {\n          rpId,\n          rpOrigins\n        },\n        signal\n      }, {\n        request: overrides\n      });\n      if (!challengeResponse) {\n        return {\n          data: null,\n          error: challengeError\n        };\n      }\n      const {\n        webauthn\n      } = challengeResponse;\n      // Verify credential\n      return this._verify({\n        factorId,\n        challengeId: challengeResponse.challengeId,\n        webauthn: {\n          type: webauthn.type,\n          rpId,\n          rpOrigins,\n          credential_response: webauthn.credential_response\n        }\n      });\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: null,\n          error\n        };\n      }\n      return {\n        data: null,\n        error: new AuthUnknownError('Unexpected error in authenticate', error)\n      };\n    }\n  }\n  /**\n   * Complete WebAuthn registration flow.\n   * Performs enrollment, challenge, and verification in a single operation for new credentials.\n   *\n   * @experimental This method is experimental and may change in future releases\n   * @param {Object} params - Registration parameters\n   * @param {string} params.friendlyName - User-friendly name for the credential\n   * @param {string} params.rpId - Relying Party ID (defaults to current hostname)\n   * @param {string[]} params.rpOrigins - Allowed origins (defaults to current origin)\n   * @param {AbortSignal} params.signal - Optional abort signal\n   * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Override options for navigator.credentials.create\n   * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Registration result\n   * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registration Ceremony}\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions MDN - PublicKeyCredentialCreationOptions}\n   */\n  async _register(_ref4, overrides) {\n    let {\n      friendlyName,\n      rpId = typeof window !== 'undefined' ? window.location.hostname : undefined,\n      rpOrigins = typeof window !== 'undefined' ? [window.location.origin] : undefined,\n      signal\n    } = _ref4;\n    if (!rpId) {\n      return {\n        data: null,\n        error: new AuthError('rpId is required for WebAuthn registration')\n      };\n    }\n    try {\n      if (!browserSupportsWebAuthn()) {\n        return {\n          data: null,\n          error: new AuthUnknownError('Browser does not support WebAuthn', null)\n        };\n      }\n      // Enroll factor\n      const {\n        data: factor,\n        error: enrollError\n      } = await this._enroll({\n        friendlyName\n      });\n      if (!factor) {\n        await this.client.mfa.listFactors().then(factors => {\n          var _a;\n          return (_a = factors.data) === null || _a === void 0 ? void 0 : _a.all.find(v => v.factor_type === 'webauthn' && v.friendly_name === friendlyName && v.status !== 'unverified');\n        }).then(factor => factor ? this.client.mfa.unenroll({\n          factorId: factor === null || factor === void 0 ? void 0 : factor.id\n        }) : void 0);\n        return {\n          data: null,\n          error: enrollError\n        };\n      }\n      // Get challenge and create credential\n      const {\n        data: challengeResponse,\n        error: challengeError\n      } = await this._challenge({\n        factorId: factor.id,\n        friendlyName: factor.friendly_name,\n        webauthn: {\n          rpId,\n          rpOrigins\n        },\n        signal\n      }, {\n        create: overrides\n      });\n      if (!challengeResponse) {\n        return {\n          data: null,\n          error: challengeError\n        };\n      }\n      return this._verify({\n        factorId: factor.id,\n        challengeId: challengeResponse.challengeId,\n        webauthn: {\n          rpId,\n          rpOrigins,\n          type: challengeResponse.webauthn.type,\n          credential_response: challengeResponse.webauthn.credential_response\n        }\n      });\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: null,\n          error\n        };\n      }\n      return {\n        data: null,\n        error: new AuthUnknownError('Unexpected error in register', error)\n      };\n    }\n  }\n}","map":{"version":3,"names":["base64UrlToUint8Array","bytesToBase64URL","AuthError","AuthUnknownError","isAuthError","isBrowser","identifyAuthenticationError","identifyRegistrationError","isWebAuthnError","WebAuthnError","WebAuthnUnknownError","WebAuthnAbortService","createNewAbortSignal","controller","abortError","Error","name","abort","newController","AbortController","signal","cancelCeremony","undefined","webAuthnAbortService","deserializeCredentialCreationOptions","options","PublicKeyCredential","parseCreationOptionsFromJSON","challenge","challengeStr","user","userOpts","excludeCredentials","restOptions","__rest","buffer","Object","assign","id","result","length","Array","i","cred","type","transports","deserializeCredentialRequestOptions","parseRequestOptionsFromJSON","allowCredentials","serializeCredentialCreationResponse","credential","toJSON","credentialWithAttachment","rawId","response","attestationObject","Uint8Array","clientDataJSON","clientExtensionResults","getClientExtensionResults","authenticatorAttachment","_a","serializeCredentialRequestResponse","assertionResponse","authenticatorData","signature","userHandle","isValidDomain","hostname","test","browserSupportsWebAuthn","window","navigator","credentials","create","_b","get","createCredential","data","error","err","getCredential","DEFAULT_CREATION_OPTIONS","hints","authenticatorSelection","requireResidentKey","userVerification","residentKey","attestation","DEFAULT_REQUEST_OPTIONS","deepMerge","isObject","val","isArray","isArrayBufferLike","ArrayBuffer","isView","_len","arguments","sources","_key","source","key","value","existing","mergeCredentialCreationOptions","baseOptions","overrides","mergeCredentialRequestOptions","WebAuthnApi","constructor","client","enroll","_enroll","bind","_challenge","verify","_verify","authenticate","_authenticate","register","_register","params","mfa","factorType","_ref","factorId","webauthn","friendlyName","challengeResponse","challengeError","abortSignal","credential_options","publicKey","concat","displayName","challengeId","credential_response","request","_ref2","_ref3","rpId","location","rpOrigins","origin","_ref4","factor","enrollError","listFactors","then","factors","all","find","v","factor_type","friendly_name","status","unenroll"],"sources":["C:\\TUGAS\\node_modules\\@supabase\\auth-js\\src\\lib\\webauthn.ts"],"sourcesContent":["import GoTrueClient from '../GoTrueClient'\nimport { base64UrlToUint8Array, bytesToBase64URL } from './base64url'\nimport { AuthError, AuthUnknownError, isAuthError } from './errors'\nimport {\n  AuthMFAEnrollWebauthnResponse,\n  AuthMFAVerifyResponse,\n  AuthMFAVerifyResponseData,\n  MFAChallengeWebauthnParams,\n  MFAEnrollWebauthnParams,\n  MFAVerifyWebauthnParamFields,\n  MFAVerifyWebauthnParams,\n  RequestResult,\n  StrictOmit,\n} from './types'\nimport { isBrowser } from './helpers'\nimport type {\n  AuthenticationCredential,\n  AuthenticationResponseJSON,\n  AuthenticatorAttachment,\n  PublicKeyCredentialCreationOptionsFuture,\n  PublicKeyCredentialCreationOptionsJSON,\n  PublicKeyCredentialFuture,\n  PublicKeyCredentialRequestOptionsFuture,\n  PublicKeyCredentialRequestOptionsJSON,\n  RegistrationCredential,\n  RegistrationResponseJSON,\n} from './webauthn.dom'\n\nimport {\n  identifyAuthenticationError,\n  identifyRegistrationError,\n  isWebAuthnError,\n  WebAuthnError,\n  WebAuthnUnknownError,\n} from './webauthn.errors'\n\nexport { WebAuthnError, isWebAuthnError, identifyRegistrationError, identifyAuthenticationError }\n// Re-export the JSON types for use in other files\nexport type { RegistrationResponseJSON, AuthenticationResponseJSON }\n\n/**\n * WebAuthn abort service to manage ceremony cancellation.\n * Ensures only one WebAuthn ceremony is active at a time to prevent \"operation already in progress\" errors.\n *\n * @experimental This class is experimental and may change in future releases\n * @see {@link https://w3c.github.io/webauthn/#sctn-automation-webdriver-capability W3C WebAuthn Spec - Aborting Ceremonies}\n */\nexport class WebAuthnAbortService {\n  private controller: AbortController | undefined\n\n  /**\n   * Create an abort signal for a new WebAuthn operation.\n   * Automatically cancels any existing operation.\n   *\n   * @returns {AbortSignal} Signal to pass to navigator.credentials.create() or .get()\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal MDN - AbortSignal}\n   */\n  createNewAbortSignal(): AbortSignal {\n    // Abort any existing calls to navigator.credentials.create() or navigator.credentials.get()\n    if (this.controller) {\n      const abortError = new Error('Cancelling existing WebAuthn API call for new one')\n      abortError.name = 'AbortError'\n      this.controller.abort(abortError)\n    }\n\n    const newController = new AbortController()\n    this.controller = newController\n    return newController.signal\n  }\n\n  /**\n   * Manually cancel the current WebAuthn operation.\n   * Useful for cleaning up when user cancels or navigates away.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort MDN - AbortController.abort}\n   */\n  cancelCeremony(): void {\n    if (this.controller) {\n      const abortError = new Error('Manually cancelling existing WebAuthn API call')\n      abortError.name = 'AbortError'\n      this.controller.abort(abortError)\n      this.controller = undefined\n    }\n  }\n}\n\n/**\n * Singleton instance to ensure only one WebAuthn ceremony is active at a time.\n * This prevents \"operation already in progress\" errors when retrying WebAuthn operations.\n *\n * @experimental This instance is experimental and may change in future releases\n */\nexport const webAuthnAbortService = new WebAuthnAbortService()\n\n/**\n * Server response format for WebAuthn credential creation options.\n * Uses W3C standard JSON format with base64url-encoded binary fields.\n */\nexport type ServerCredentialCreationOptions = PublicKeyCredentialCreationOptionsJSON\n\n/**\n * Server response format for WebAuthn credential request options.\n * Uses W3C standard JSON format with base64url-encoded binary fields.\n */\nexport type ServerCredentialRequestOptions = PublicKeyCredentialRequestOptionsJSON\n\n/**\n * Convert base64url encoded strings in WebAuthn credential creation options to ArrayBuffers\n * as required by the WebAuthn browser API.\n * Supports both native WebAuthn Level 3 parseCreationOptionsFromJSON and manual fallback.\n *\n * @param {ServerCredentialCreationOptions} options - JSON options from server with base64url encoded fields\n * @returns {PublicKeyCredentialCreationOptionsFuture} Options ready for navigator.credentials.create()\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseCreationOptionsFromJSON W3C WebAuthn Spec - parseCreationOptionsFromJSON}\n */\nexport function deserializeCredentialCreationOptions(\n  options: ServerCredentialCreationOptions\n): PublicKeyCredentialCreationOptionsFuture {\n  if (!options) {\n    throw new Error('Credential creation options are required')\n  }\n\n  // Check if the native parseCreationOptionsFromJSON method is available\n  if (\n    typeof PublicKeyCredential !== 'undefined' &&\n    'parseCreationOptionsFromJSON' in PublicKeyCredential &&\n    typeof (PublicKeyCredential as unknown as PublicKeyCredentialFuture)\n      .parseCreationOptionsFromJSON === 'function'\n  ) {\n    // Use the native WebAuthn Level 3 method\n    return (\n      PublicKeyCredential as unknown as PublicKeyCredentialFuture\n    ).parseCreationOptionsFromJSON(\n      /** we assert the options here as typescript still doesn't know about future webauthn types */\n      options as any\n    ) as PublicKeyCredentialCreationOptionsFuture\n  }\n\n  // Fallback to manual parsing for browsers that don't support the native method\n  // Destructure to separate fields that need transformation\n  const { challenge: challengeStr, user: userOpts, excludeCredentials, ...restOptions } = options\n\n  // Convert challenge from base64url to ArrayBuffer\n  const challenge = base64UrlToUint8Array(challengeStr).buffer as ArrayBuffer\n\n  // Convert user.id from base64url to ArrayBuffer\n  const user: PublicKeyCredentialUserEntity = {\n    ...userOpts,\n    id: base64UrlToUint8Array(userOpts.id).buffer as ArrayBuffer,\n  }\n\n  // Build the result object\n  const result: PublicKeyCredentialCreationOptionsFuture = {\n    ...restOptions,\n    challenge,\n    user,\n  }\n\n  // Only add excludeCredentials if it exists\n  if (excludeCredentials && excludeCredentials.length > 0) {\n    result.excludeCredentials = new Array(excludeCredentials.length)\n\n    for (let i = 0; i < excludeCredentials.length; i++) {\n      const cred = excludeCredentials[i]\n      result.excludeCredentials[i] = {\n        ...cred,\n        id: base64UrlToUint8Array(cred.id).buffer,\n        type: cred.type || 'public-key',\n        // Cast transports to handle future transport types like \"cable\"\n        transports: cred.transports,\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * Convert base64url encoded strings in WebAuthn credential request options to ArrayBuffers\n * as required by the WebAuthn browser API.\n * Supports both native WebAuthn Level 3 parseRequestOptionsFromJSON and manual fallback.\n *\n * @param {ServerCredentialRequestOptions} options - JSON options from server with base64url encoded fields\n * @returns {PublicKeyCredentialRequestOptionsFuture} Options ready for navigator.credentials.get()\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseRequestOptionsFromJSON W3C WebAuthn Spec - parseRequestOptionsFromJSON}\n */\nexport function deserializeCredentialRequestOptions(\n  options: ServerCredentialRequestOptions\n): PublicKeyCredentialRequestOptionsFuture {\n  if (!options) {\n    throw new Error('Credential request options are required')\n  }\n\n  // Check if the native parseRequestOptionsFromJSON method is available\n  if (\n    typeof PublicKeyCredential !== 'undefined' &&\n    'parseRequestOptionsFromJSON' in PublicKeyCredential &&\n    typeof (PublicKeyCredential as unknown as PublicKeyCredentialFuture)\n      .parseRequestOptionsFromJSON === 'function'\n  ) {\n    // Use the native WebAuthn Level 3 method\n    return (\n      PublicKeyCredential as unknown as PublicKeyCredentialFuture\n    ).parseRequestOptionsFromJSON(options) as PublicKeyCredentialRequestOptionsFuture\n  }\n\n  // Fallback to manual parsing for browsers that don't support the native method\n  // Destructure to separate fields that need transformation\n  const { challenge: challengeStr, allowCredentials, ...restOptions } = options\n\n  // Convert challenge from base64url to ArrayBuffer\n  const challenge = base64UrlToUint8Array(challengeStr).buffer as ArrayBuffer\n\n  // Build the result object\n  const result: PublicKeyCredentialRequestOptionsFuture = {\n    ...restOptions,\n    challenge,\n  }\n\n  // Only add allowCredentials if it exists\n  if (allowCredentials && allowCredentials.length > 0) {\n    result.allowCredentials = new Array(allowCredentials.length)\n\n    for (let i = 0; i < allowCredentials.length; i++) {\n      const cred = allowCredentials[i]\n      result.allowCredentials[i] = {\n        ...cred,\n        id: base64UrlToUint8Array(cred.id).buffer,\n        type: cred.type || 'public-key',\n        // Cast transports to handle future transport types like \"cable\"\n        transports: cred.transports,\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * Server format for credential response with base64url-encoded binary fields\n * Can be either a registration or authentication response\n */\nexport type ServerCredentialResponse = RegistrationResponseJSON | AuthenticationResponseJSON\n\n/**\n * Convert a registration/enrollment credential response to server format.\n * Serializes binary fields to base64url for JSON transmission.\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\n *\n * @param {RegistrationCredential} credential - Credential from navigator.credentials.create()\n * @returns {RegistrationResponseJSON} JSON-serializable credential for server\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\n */\nexport function serializeCredentialCreationResponse(\n  credential: RegistrationCredential\n): RegistrationResponseJSON {\n  // Check if the credential instance has the toJSON method\n  if ('toJSON' in credential && typeof credential.toJSON === 'function') {\n    // Use the native WebAuthn Level 3 method\n    return (credential as RegistrationCredential).toJSON()\n  }\n  const credentialWithAttachment = credential as PublicKeyCredential & {\n    response: AuthenticatorAttestationResponse\n    authenticatorAttachment?: string | null\n  }\n\n  return {\n    id: credential.id,\n    rawId: credential.id,\n    response: {\n      attestationObject: bytesToBase64URL(new Uint8Array(credential.response.attestationObject)),\n      clientDataJSON: bytesToBase64URL(new Uint8Array(credential.response.clientDataJSON)),\n    },\n    type: 'public-key',\n    clientExtensionResults: credential.getClientExtensionResults(),\n    // Convert null to undefined and cast to AuthenticatorAttachment type\n    authenticatorAttachment: (credentialWithAttachment.authenticatorAttachment ?? undefined) as\n      | AuthenticatorAttachment\n      | undefined,\n  }\n}\n\n/**\n * Convert an authentication/verification credential response to server format.\n * Serializes binary fields to base64url for JSON transmission.\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\n *\n * @param {AuthenticationCredential} credential - Credential from navigator.credentials.get()\n * @returns {AuthenticationResponseJSON} JSON-serializable credential for server\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\n */\nexport function serializeCredentialRequestResponse(\n  credential: AuthenticationCredential\n): AuthenticationResponseJSON {\n  // Check if the credential instance has the toJSON method\n  if ('toJSON' in credential && typeof credential.toJSON === 'function') {\n    // Use the native WebAuthn Level 3 method\n    return (credential as AuthenticationCredential).toJSON()\n  }\n\n  // Fallback to manual conversion for browsers that don't support toJSON\n  // Access authenticatorAttachment via type assertion to handle TypeScript version differences\n  // @simplewebauthn/types includes this property but base TypeScript 4.7.4 doesn't\n  const credentialWithAttachment = credential as PublicKeyCredential & {\n    response: AuthenticatorAssertionResponse\n    authenticatorAttachment?: string | null\n  }\n\n  const clientExtensionResults = credential.getClientExtensionResults()\n  const assertionResponse = credential.response\n\n  return {\n    id: credential.id,\n    rawId: credential.id, // W3C spec expects rawId to match id for JSON format\n    response: {\n      authenticatorData: bytesToBase64URL(new Uint8Array(assertionResponse.authenticatorData)),\n      clientDataJSON: bytesToBase64URL(new Uint8Array(assertionResponse.clientDataJSON)),\n      signature: bytesToBase64URL(new Uint8Array(assertionResponse.signature)),\n      userHandle: assertionResponse.userHandle\n        ? bytesToBase64URL(new Uint8Array(assertionResponse.userHandle))\n        : undefined,\n    },\n    type: 'public-key',\n    clientExtensionResults,\n    // Convert null to undefined and cast to AuthenticatorAttachment type\n    authenticatorAttachment: (credentialWithAttachment.authenticatorAttachment ?? undefined) as\n      | AuthenticatorAttachment\n      | undefined,\n  }\n}\n\n/**\n * A simple test to determine if a hostname is a properly-formatted domain name.\n * Considers localhost valid for development environments.\n *\n * A \"valid domain\" is defined here: https://url.spec.whatwg.org/#valid-domain\n *\n * Regex sourced from here:\n * https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch08s15.html\n *\n * @param {string} hostname - The hostname to validate\n * @returns {boolean} True if valid domain or localhost\n * @see {@link https://url.spec.whatwg.org/#valid-domain WHATWG URL Spec - Valid Domain}\n */\nexport function isValidDomain(hostname: string): boolean {\n  return (\n    // Consider localhost valid as well since it's okay wrt Secure Contexts\n    hostname === 'localhost' || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname)\n  )\n}\n\n/**\n * Determine if the browser is capable of WebAuthn.\n * Checks for necessary Web APIs: PublicKeyCredential and Credential Management.\n *\n * @returns {boolean} True if browser supports WebAuthn\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential#browser_compatibility MDN - PublicKeyCredential Browser Compatibility}\n */\nfunction browserSupportsWebAuthn(): boolean {\n  return !!(\n    isBrowser() &&\n    'PublicKeyCredential' in window &&\n    window.PublicKeyCredential &&\n    'credentials' in navigator &&\n    typeof navigator?.credentials?.create === 'function' &&\n    typeof navigator?.credentials?.get === 'function'\n  )\n}\n\n/**\n * Create a WebAuthn credential using the browser's credentials API.\n * Wraps navigator.credentials.create() with error handling.\n *\n * @param {CredentialCreationOptions} options - Options including publicKey parameters\n * @returns {Promise<RequestResult<RegistrationCredential, WebAuthnError>>} Created credential or error\n * @see {@link https://w3c.github.io/webauthn/#sctn-createCredential W3C WebAuthn Spec - Create Credential}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/create MDN - credentials.create}\n */\nexport async function createCredential(\n  options: StrictOmit<CredentialCreationOptions, 'publicKey'> & {\n    publicKey: PublicKeyCredentialCreationOptionsFuture\n  }\n): Promise<RequestResult<RegistrationCredential, WebAuthnError>> {\n  try {\n    const response = await navigator.credentials.create(\n      /** we assert the type here until typescript types are updated */\n      options as Parameters<typeof navigator.credentials.create>[0]\n    )\n    if (!response) {\n      return {\n        data: null,\n        error: new WebAuthnUnknownError('Empty credential response', response),\n      }\n    }\n    if (!(response instanceof PublicKeyCredential)) {\n      return {\n        data: null,\n        error: new WebAuthnUnknownError('Browser returned unexpected credential type', response),\n      }\n    }\n    return { data: response as RegistrationCredential, error: null }\n  } catch (err) {\n    return {\n      data: null,\n      error: identifyRegistrationError({\n        error: err as Error,\n        options,\n      }),\n    }\n  }\n}\n\n/**\n * Get a WebAuthn credential using the browser's credentials API.\n * Wraps navigator.credentials.get() with error handling.\n *\n * @param {CredentialRequestOptions} options - Options including publicKey parameters\n * @returns {Promise<RequestResult<AuthenticationCredential, WebAuthnError>>} Retrieved credential or error\n * @see {@link https://w3c.github.io/webauthn/#sctn-getAssertion W3C WebAuthn Spec - Get Assertion}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get MDN - credentials.get}\n */\nexport async function getCredential(\n  options: StrictOmit<CredentialRequestOptions, 'publicKey'> & {\n    publicKey: PublicKeyCredentialRequestOptionsFuture\n  }\n): Promise<RequestResult<AuthenticationCredential, WebAuthnError>> {\n  try {\n    const response = await navigator.credentials.get(\n      /** we assert the type here until typescript types are updated */\n      options as Parameters<typeof navigator.credentials.get>[0]\n    )\n    if (!response) {\n      return {\n        data: null,\n        error: new WebAuthnUnknownError('Empty credential response', response),\n      }\n    }\n    if (!(response instanceof PublicKeyCredential)) {\n      return {\n        data: null,\n        error: new WebAuthnUnknownError('Browser returned unexpected credential type', response),\n      }\n    }\n    return { data: response as AuthenticationCredential, error: null }\n  } catch (err) {\n    return {\n      data: null,\n      error: identifyAuthenticationError({\n        error: err as Error,\n        options,\n      }),\n    }\n  }\n}\n\nexport const DEFAULT_CREATION_OPTIONS: Partial<PublicKeyCredentialCreationOptionsFuture> = {\n  hints: ['security-key'],\n  authenticatorSelection: {\n    authenticatorAttachment: 'cross-platform',\n    requireResidentKey: false,\n    /** set to preferred because older yubikeys don't have PIN/Biometric */\n    userVerification: 'preferred',\n    residentKey: 'discouraged',\n  },\n  attestation: 'none',\n}\n\nexport const DEFAULT_REQUEST_OPTIONS: Partial<PublicKeyCredentialRequestOptionsFuture> = {\n  /** set to preferred because older yubikeys don't have PIN/Biometric */\n  userVerification: 'preferred',\n  hints: ['security-key'],\n}\n\nfunction deepMerge<T>(...sources: Partial<T>[]): T {\n  const isObject = (val: unknown): val is Record<string, unknown> =>\n    val !== null && typeof val === 'object' && !Array.isArray(val)\n\n  const isArrayBufferLike = (val: unknown): val is ArrayBuffer | ArrayBufferView =>\n    val instanceof ArrayBuffer || ArrayBuffer.isView(val)\n\n  const result: Partial<T> = {}\n\n  for (const source of sources) {\n    if (!source) continue\n\n    for (const key in source) {\n      const value = source[key]\n      if (value === undefined) continue\n\n      if (Array.isArray(value)) {\n        // preserve array reference, including unions like AuthenticatorTransport[]\n        result[key] = value as T[typeof key]\n      } else if (isArrayBufferLike(value)) {\n        result[key] = value as T[typeof key]\n      } else if (isObject(value)) {\n        const existing = result[key]\n        if (isObject(existing)) {\n          result[key] = deepMerge(existing, value) as unknown as T[typeof key]\n        } else {\n          result[key] = deepMerge(value) as unknown as T[typeof key]\n        }\n      } else {\n        result[key] = value as T[typeof key]\n      }\n    }\n  }\n\n  return result as T\n}\n\n/**\n * Merges WebAuthn credential creation options with overrides.\n * Sets sensible defaults for authenticator selection and extensions.\n *\n * @param {PublicKeyCredentialCreationOptionsFuture} baseOptions - The base options from the server\n * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Optional overrides to apply\n * @param {string} friendlyName - Optional friendly name for the credential\n * @returns {PublicKeyCredentialCreationOptionsFuture} Merged credential creation options\n * @see {@link https://w3c.github.io/webauthn/#dictdef-authenticatorselectioncriteria W3C WebAuthn Spec - AuthenticatorSelectionCriteria}\n */\nexport function mergeCredentialCreationOptions(\n  baseOptions: PublicKeyCredentialCreationOptionsFuture,\n  overrides?: Partial<PublicKeyCredentialCreationOptionsFuture>\n): PublicKeyCredentialCreationOptionsFuture {\n  return deepMerge(DEFAULT_CREATION_OPTIONS, baseOptions, overrides || {})\n}\n\n/**\n * Merges WebAuthn credential request options with overrides.\n * Sets sensible defaults for user verification and hints.\n *\n * @param {PublicKeyCredentialRequestOptionsFuture} baseOptions - The base options from the server\n * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Optional overrides to apply\n * @returns {PublicKeyCredentialRequestOptionsFuture} Merged credential request options\n * @see {@link https://w3c.github.io/webauthn/#dictdef-publickeycredentialrequestoptions W3C WebAuthn Spec - PublicKeyCredentialRequestOptions}\n */\nexport function mergeCredentialRequestOptions(\n  baseOptions: PublicKeyCredentialRequestOptionsFuture,\n  overrides?: Partial<PublicKeyCredentialRequestOptionsFuture>\n): PublicKeyCredentialRequestOptionsFuture {\n  return deepMerge(DEFAULT_REQUEST_OPTIONS, baseOptions, overrides || {})\n}\n\n/**\n * WebAuthn API wrapper for Supabase Auth.\n * Provides methods for enrolling, challenging, verifying, authenticating, and registering WebAuthn credentials.\n *\n * @experimental This API is experimental and may change in future releases\n * @see {@link https://w3c.github.io/webauthn/ W3C WebAuthn Specification}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API MDN - Web Authentication API}\n */\nexport class WebAuthnApi {\n  public enroll: typeof WebAuthnApi.prototype._enroll\n  public challenge: typeof WebAuthnApi.prototype._challenge\n  public verify: typeof WebAuthnApi.prototype._verify\n  public authenticate: typeof WebAuthnApi.prototype._authenticate\n  public register: typeof WebAuthnApi.prototype._register\n\n  constructor(private client: GoTrueClient) {\n    // Bind all methods so they can be destructured\n    this.enroll = this._enroll.bind(this)\n    this.challenge = this._challenge.bind(this)\n    this.verify = this._verify.bind(this)\n    this.authenticate = this._authenticate.bind(this)\n    this.register = this._register.bind(this)\n  }\n\n  /**\n   * Enroll a new WebAuthn factor.\n   * Creates an unverified WebAuthn factor that must be verified with a credential.\n   *\n   * @experimental This method is experimental and may change in future releases\n   * @param {Omit<MFAEnrollWebauthnParams, 'factorType'>} params - Enrollment parameters (friendlyName required)\n   * @returns {Promise<AuthMFAEnrollWebauthnResponse>} Enrolled factor details or error\n   * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registering a New Credential}\n   */\n  public async _enroll(\n    params: Omit<MFAEnrollWebauthnParams, 'factorType'>\n  ): Promise<AuthMFAEnrollWebauthnResponse> {\n    return this.client.mfa.enroll({ ...params, factorType: 'webauthn' })\n  }\n\n  /**\n   * Challenge for WebAuthn credential creation or authentication.\n   * Combines server challenge with browser credential operations.\n   * Handles both registration (create) and authentication (request) flows.\n   *\n   * @experimental This method is experimental and may change in future releases\n   * @param {MFAChallengeWebauthnParams & { friendlyName?: string; signal?: AbortSignal }} params - Challenge parameters including factorId\n   * @param {Object} overrides - Allows you to override the parameters passed to navigator.credentials\n   * @param {PublicKeyCredentialCreationOptionsFuture} overrides.create - Override options for credential creation\n   * @param {PublicKeyCredentialRequestOptionsFuture} overrides.request - Override options for credential request\n   * @returns {Promise<RequestResult>} Challenge response with credential or error\n   * @see {@link https://w3c.github.io/webauthn/#sctn-credential-creation W3C WebAuthn Spec - Credential Creation}\n   * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying Assertion}\n   */\n  public async _challenge(\n    {\n      factorId,\n      webauthn,\n      friendlyName,\n      signal,\n    }: MFAChallengeWebauthnParams & { friendlyName?: string; signal?: AbortSignal },\n    overrides?:\n      | {\n          create?: Partial<PublicKeyCredentialCreationOptionsFuture>\n          request?: never\n        }\n      | {\n          create?: never\n          request?: Partial<PublicKeyCredentialRequestOptionsFuture>\n        }\n  ): Promise<\n    RequestResult<\n      { factorId: string; challengeId: string } & {\n        webauthn: StrictOmit<\n          MFAVerifyWebauthnParamFields<'create' | 'request'>['webauthn'],\n          'rpId' | 'rpOrigins'\n        >\n      },\n      WebAuthnError | AuthError\n    >\n  > {\n    try {\n      // Get challenge from server using the client's MFA methods\n      const { data: challengeResponse, error: challengeError } = await this.client.mfa.challenge({\n        factorId,\n        webauthn,\n      })\n\n      if (!challengeResponse) {\n        return { data: null, error: challengeError }\n      }\n\n      const abortSignal = signal ?? webAuthnAbortService.createNewAbortSignal()\n\n      /** webauthn will fail if either of the name/displayname are blank */\n      if (challengeResponse.webauthn.type === 'create') {\n        const { user } = challengeResponse.webauthn.credential_options.publicKey\n        if (!user.name) {\n          user.name = `${user.id}:${friendlyName}`\n        }\n        if (!user.displayName) {\n          user.displayName = user.name\n        }\n      }\n\n      switch (challengeResponse.webauthn.type) {\n        case 'create': {\n          const options = mergeCredentialCreationOptions(\n            challengeResponse.webauthn.credential_options.publicKey,\n            overrides?.create\n          )\n\n          const { data, error } = await createCredential({\n            publicKey: options,\n            signal: abortSignal,\n          })\n\n          if (data) {\n            return {\n              data: {\n                factorId,\n                challengeId: challengeResponse.id,\n                webauthn: {\n                  type: challengeResponse.webauthn.type,\n                  credential_response: data,\n                },\n              },\n              error: null,\n            }\n          }\n          return { data: null, error }\n        }\n\n        case 'request': {\n          const options = mergeCredentialRequestOptions(\n            challengeResponse.webauthn.credential_options.publicKey,\n            overrides?.request\n          )\n\n          const { data, error } = await getCredential({\n            ...challengeResponse.webauthn.credential_options,\n            publicKey: options,\n            signal: abortSignal,\n          })\n\n          if (data) {\n            return {\n              data: {\n                factorId,\n                challengeId: challengeResponse.id,\n                webauthn: {\n                  type: challengeResponse.webauthn.type,\n                  credential_response: data,\n                },\n              },\n              error: null,\n            }\n          }\n          return { data: null, error }\n        }\n      }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      return {\n        data: null,\n        error: new AuthUnknownError('Unexpected error in challenge', error),\n      }\n    }\n  }\n\n  /**\n   * Verify a WebAuthn credential with the server.\n   * Completes the WebAuthn ceremony by sending the credential to the server for verification.\n   *\n   * @experimental This method is experimental and may change in future releases\n   * @param {Object} params - Verification parameters\n   * @param {string} params.challengeId - ID of the challenge being verified\n   * @param {string} params.factorId - ID of the WebAuthn factor\n   * @param {MFAVerifyWebauthnParams<T>['webauthn']} params.webauthn - WebAuthn credential response\n   * @returns {Promise<AuthMFAVerifyResponse>} Verification result with session or error\n   * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying an Authentication Assertion}\n   * */\n  public async _verify<T extends 'create' | 'request'>({\n    challengeId,\n    factorId,\n    webauthn,\n  }: {\n    challengeId: string\n    factorId: string\n    webauthn: MFAVerifyWebauthnParams<T>['webauthn']\n  }): Promise<AuthMFAVerifyResponse> {\n    return this.client.mfa.verify({\n      factorId,\n      challengeId,\n      webauthn: webauthn,\n    })\n  }\n\n  /**\n   * Complete WebAuthn authentication flow.\n   * Performs challenge and verification in a single operation for existing credentials.\n   *\n   * @experimental This method is experimental and may change in future releases\n   * @param {Object} params - Authentication parameters\n   * @param {string} params.factorId - ID of the WebAuthn factor to authenticate with\n   * @param {Object} params.webauthn - WebAuthn configuration\n   * @param {string} params.webauthn.rpId - Relying Party ID (defaults to current hostname)\n   * @param {string[]} params.webauthn.rpOrigins - Allowed origins (defaults to current origin)\n   * @param {AbortSignal} params.webauthn.signal - Optional abort signal\n   * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Override options for navigator.credentials.get\n   * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Authentication result\n   * @see {@link https://w3c.github.io/webauthn/#sctn-authentication W3C WebAuthn Spec - Authentication Ceremony}\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions MDN - PublicKeyCredentialRequestOptions}\n   */\n  public async _authenticate(\n    {\n      factorId,\n      webauthn: {\n        rpId = typeof window !== 'undefined' ? window.location.hostname : undefined,\n        rpOrigins = typeof window !== 'undefined' ? [window.location.origin] : undefined,\n        signal,\n      },\n    }: {\n      factorId: string\n      webauthn: {\n        rpId?: string\n        rpOrigins?: string[]\n        signal?: AbortSignal\n      }\n    },\n    overrides?: PublicKeyCredentialRequestOptionsFuture\n  ): Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>> {\n    if (!rpId) {\n      return {\n        data: null,\n        error: new AuthError('rpId is required for WebAuthn authentication'),\n      }\n    }\n    try {\n      if (!browserSupportsWebAuthn()) {\n        return {\n          data: null,\n          error: new AuthUnknownError('Browser does not support WebAuthn', null),\n        }\n      }\n\n      // Get challenge and credential\n      const { data: challengeResponse, error: challengeError } = await this.challenge(\n        {\n          factorId,\n          webauthn: { rpId, rpOrigins },\n          signal,\n        },\n        { request: overrides }\n      )\n\n      if (!challengeResponse) {\n        return { data: null, error: challengeError }\n      }\n\n      const { webauthn } = challengeResponse\n\n      // Verify credential\n      return this._verify({\n        factorId,\n        challengeId: challengeResponse.challengeId,\n        webauthn: {\n          type: webauthn.type,\n          rpId,\n          rpOrigins,\n          credential_response: webauthn.credential_response,\n        },\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      return {\n        data: null,\n        error: new AuthUnknownError('Unexpected error in authenticate', error),\n      }\n    }\n  }\n\n  /**\n   * Complete WebAuthn registration flow.\n   * Performs enrollment, challenge, and verification in a single operation for new credentials.\n   *\n   * @experimental This method is experimental and may change in future releases\n   * @param {Object} params - Registration parameters\n   * @param {string} params.friendlyName - User-friendly name for the credential\n   * @param {string} params.rpId - Relying Party ID (defaults to current hostname)\n   * @param {string[]} params.rpOrigins - Allowed origins (defaults to current origin)\n   * @param {AbortSignal} params.signal - Optional abort signal\n   * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Override options for navigator.credentials.create\n   * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Registration result\n   * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registration Ceremony}\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions MDN - PublicKeyCredentialCreationOptions}\n   */\n  public async _register(\n    {\n      friendlyName,\n      rpId = typeof window !== 'undefined' ? window.location.hostname : undefined,\n      rpOrigins = typeof window !== 'undefined' ? [window.location.origin] : undefined,\n      signal,\n    }: {\n      friendlyName: string\n      rpId?: string\n      rpOrigins?: string[]\n      signal?: AbortSignal\n    },\n    overrides?: Partial<PublicKeyCredentialCreationOptionsFuture>\n  ): Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>> {\n    if (!rpId) {\n      return {\n        data: null,\n        error: new AuthError('rpId is required for WebAuthn registration'),\n      }\n    }\n    try {\n      if (!browserSupportsWebAuthn()) {\n        return {\n          data: null,\n          error: new AuthUnknownError('Browser does not support WebAuthn', null),\n        }\n      }\n\n      // Enroll factor\n      const { data: factor, error: enrollError } = await this._enroll({\n        friendlyName,\n      })\n\n      if (!factor) {\n        await this.client.mfa\n          .listFactors()\n          .then((factors) =>\n            factors.data?.all.find(\n              (v) =>\n                v.factor_type === 'webauthn' &&\n                v.friendly_name === friendlyName &&\n                v.status !== 'unverified'\n            )\n          )\n          .then((factor) => (factor ? this.client.mfa.unenroll({ factorId: factor?.id }) : void 0))\n        return { data: null, error: enrollError }\n      }\n\n      // Get challenge and create credential\n      const { data: challengeResponse, error: challengeError } = await this._challenge(\n        {\n          factorId: factor.id,\n          friendlyName: factor.friendly_name,\n          webauthn: { rpId, rpOrigins },\n          signal,\n        },\n        {\n          create: overrides,\n        }\n      )\n\n      if (!challengeResponse) {\n        return { data: null, error: challengeError }\n      }\n\n      return this._verify({\n        factorId: factor.id,\n        challengeId: challengeResponse.challengeId,\n        webauthn: {\n          rpId,\n          rpOrigins,\n          type: challengeResponse.webauthn.type,\n          credential_response: challengeResponse.webauthn.credential_response,\n        },\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      return {\n        data: null,\n        error: new AuthUnknownError('Unexpected error in register', error),\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}